<!doctype html>
<html>
<body>
<xmp>
---
// example of shuffling different colors
let stimuli = []

for (let color of ["red", "green", "blue", "yellow"]) {
	stimuli.push(new Solid(120,color))
}

r.shuffle(stimuli)
for (let stimulus of stimuli) {
	yield stimulus
	yield new Solid(120)
}


---
// "light wedge" of different durations
let solid = []

// .1 second steps through 6 seconds
for (let i=12; i<=6*120; i=i+12) {
	solid.push(new Solid(i))
}

// 5 repetitions
for (let i = 0; i < 5; i++) {
	r.shuffle(solid)
	for (let stimulus of solid) {
		yield stimulus
		yield new Solid(240)
	}
}

---
// v2

// acuity to bars of different widths and speeds

function linearToHex(f) {
    // gamma compress linear light intensity between zero and one
    let n = Math.ceil((1.055*Math.pow(f,1/2.4)-0.055)*255)
    let hex = n.toString(16)
    return "#"+hex+hex+hex
}

function* wrapSolid(stimuli) {
	// insert a wait before and after
	for (let s of stimuli) {
		if (s.stimulusType==="SOLID") {
			yield waitSC(120)
			yield s
			yield waitSC(240)
		} else {
			yield s
		}
	}
}

function* measureIntegrity(stimuli,every=5*60) {
	// every N seconds, do a flash
	let elapsedTime = every
	for (let s of stimuli) {
		if (elapsedTime>=every) {
			yield waitSC(120)
			yield solidSC(60)
			yield waitSC(240)
			elapsedTime = 0
			yield s
		} else {
			yield s
			elapsedTime=elapsedTime+s["lifespan"]/120
		}
	}
}

let widths = new Set()
let EQspeeds = [15,30,60,120,240,480,960,1920]
let whiteFlashLifetime = new Set()
let colorFlashLifetime = new Set()
let stimuli = []

let steps = 8
let widthStep = 2
let maxWidth = widthStep * steps

let width
let duration
let lifespan
let speed
let exponent

for (let i = 0; i < EQspeeds.length; i++) {
	speed = EQspeeds[i]
	exponent = 7+i<10 ? 7+i : 10

	for (let w = 0; w <= exponent; w++) {
		width = Math.pow(2,w)
		lifespan = calcBarLifespan(speed,width,windowHeight,windowWidth)
		// we use an offset to avoid diamond pixel artifacts
		stimuli.push(barSC(lifespan,"black","white",speed,width,PI/8))
		duration = Math.ceil(width/speed*120)
		whiteFlashLifetime.add(duration)
	}
}

let colors = [0.2,0.4,0.6,0.8].map(linearToHex)

for (let i = 3; i < EQspeeds.length-1; i++) {
	// skip the slow speeds & the fastest

	speed = EQspeeds[i]
	exponent = 7+i<1 ? 7+i : 10
	// widths of [16,32,64,128,256]
	for (let w = 4; w <= 8; w++) {
		width = Math.pow(2,w)
		lifespan = calcBarLifespan(speed,width,windowHeight,windowWidth)
		duration = Math.ceil(width/speed*120)
		
		// Here we do Direction selectively
		for (var j=1; j<=7;j++) {
			// 8 angles, offset by 22 degrees to reduce diamond artifact
			stimuli.push(barSC(lifespan,"black","white",speed,width,(j*2+1)*PI/8))
		}

		// and now we do contrast
		for (let c of colors) {
			stimuli.push(barSC(lifespan,"black",c,speed,width,PI/8))
			colorFlashLifetime.add(duration,c)
		}
	}
}

for (let s of whiteFlashLifetime) {
	stimuli.push(solidSC(s))
}

for (let s of colorFlashLifetime) {
	for (let c of colors) {
		stimuli.push(solidSC(s,c))
	}
}

r.shuffle(stimuli)

let stimulusGenerator = measureIntegrity(wrapSolid(stimuli))
for (let s of stimulusGenerator) {
	yield s
}
---
// v1
// acuity to bars of different widths and speeds
let widths = new Set()
let speeds = [60,120,240,480,960,1920,4840]
let lightDuration = new Set()
let stimuli = []

let steps = 8
let widthStep = 2
let maxWidth = widthStep * steps
// let initialSpeed = 60
// let speedStep = 60
// let maxSpeed = initialSpeed + speedStep * steps

// for (let s = initialSpeed; s <= maxSpeed; s=s+speedStep) {
// 	speeds.push(s)
// }

// this gives thirty-one widths from 1-512
// with 6 equivalency bands of 8 speeds
let width
let duration
let lifespan

widths.add(1)
for (let w = widthStep; w <= maxWidth; w=w+widthStep) {
	for (let i = 0; i<7;i++) {
		width = w*Math.pow(2,i)
		widths.add(width)
	}
}

for (let w of widths) {
	for (let s of speeds) {
		// need to round to frames
		lifespan = calcBarLifespan(s,w,windowHeight,windowWidth)
		stimuli.push(barSC(lifespan,"black","white",s,w,0))
		duration = Math.ceil(w/s*120)
		lightDuration.add(duration)
	}
}

for (let d of lightDuration) {
	stimuli.push(solidSC(d))
}

r.shuffle(stimuli)

// insert a wait before and after
for (let s of stimuli) {
	if (s.stimulusType==="SOLID") {
		yield waitSC(120)
		yield s
		yield waitSC(240)
	} else {
		yield s
	}
}

---
// color acuity (2h30m)


// acuity to bars of different widths and speeds
let widths = new Set()
let speeds = []
let lightDuration = new Set()
let stimuli = []

let steps = 8
let speedStep = 60
let widthStep = 2


let maxWidth = widthStep * steps
let maxSpeed = speedStep * steps

for (let s = speedStep; s < maxSpeed; s=s+speedStep) {
	speeds.push(s)
}

// this gives thirty widths from 2-512
// with 6 equivalency bands of 8 speeds
let width
let duration
let lifespan
for (let w = widthStep; w <= maxWidth; w=w+widthStep) {
	for (let i = 0; i<6;i++) {
		width = w*Math.pow(2,i)
		widths.add(width)
	}
}

for (let w of widths) {
	for (let s of speeds) {
		// need to round to frames
		lifespan = calcBarLifespan(s,w,windowHeight,windowWidth)
		stimuli.push(barSC(lifespan,"black","white",s,w,0))
		stimuli.push(barSC(lifespan,"black","blue",s,w,0))
		stimuli.push(barSC(lifespan,"black","green",s,w,0))
		stimuli.push(barSC(lifespan,"black","red",s,w,0))
		duration = Math.ceil(w/s*120)
		lightDuration.add(duration)
	}
}

for (let d of lightDuration) {
	stimuli.push(solidSC(d, "white"))
	stimuli.push(solidSC(d,"blue"))
	stimuli.push(solidSC(d,"green"))
	stimuli.push(solidSC(d,"red"))
}

r.shuffle(stimuli)

// insert a wait before and after
for (let s of stimuli) {
	if (s.stimulusType==="SOLID") {
		yield waitSC(120)
		yield s
		yield waitSC(240)
	} else {
		yield s
	}
}

---
// color direction selectively

let angles

const numberOfAngles = 64
const stimuli = []
let lifespan

let speed = 240
let width = 15
for (let i=0; i<numberOfAngles; i++) {
	lifespan = calcBarLifespan(speed,width,windowHeight,windowWidth)
	stimuli.push(barSC(lifespan,"black","white",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","red",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","blue",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","green",speed,width,i*2/numberOfAngles*PI))
}

speed = 240
width = 30
for (let i=0; i<numberOfAngles; i++) {
	lifespan = calcBarLifespan(speed,width,windowHeight,windowWidth)
	stimuli.push(barSC(lifespan,"black","white",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","red",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","blue",speed,width,i*2/numberOfAngles*PI))
	stimuli.push(barSC(lifespan,"black","green",speed,width,i*2/numberOfAngles*PI))
}


// .1 second steps through 6 seconds
for (let i=12; i<=6*120; i=i+12) {
	stimuli.push(solidSC(i))
	stimuli.push(solidSC(i,"red"))
	stimuli.push(solidSC(i,"blue"))
	stimuli.push(solidSC(i,"green"))
}

r.shuffle(stimuli)

// insert a wait before and after
for (let s of stimuli) {
	if (s.stimulusType==="SOLID") {
		yield waitSC(120)
		yield s
		yield waitSC(240)
	} else {
		yield s
	}
}

---
// BELOW THIS IS NOT FINISHED

---
// BELOW THIS IS NOT FINISHED

---
// BELOW THIS IS NOT FINISHED

---
// BELOW THIS IS NOT FINISHED


</xmp>

</body>
</html>